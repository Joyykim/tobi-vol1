# 토비의 스프링 정리 1장

---
## 1. DAO의 분리
전체적으로 OCP에 대한 내용을 쉽게 풀어서 설명하고 있다.

### 관심사의 분리
```
- 중복 코드의 추출, 상속, 컴포지션 순으로 코드의 재활용성 방법과 리팩토링 방법을 설명한다.
- 상속을 사용함으로써 발생하는 결합도에 대한 문제와 LSP와 같은 문제를 언급하며 결국 조합을 사용하도록 유도한다.
```

- 중복 코드 추출
	- 관심의 종류에 따라 코드를 분류하였기 때문에, 한가지 관심에 대한 변경이 자유롭다.
	
- 상속을 통한 확장
	- 템플릿 메소드 패턴을 통해 코드의 중복을 줄이고 유연한 객체를 생성할 수 있음.
	- 하지만 상속으로 인해 캡슐화에 문제가 발생하며 다중상속을 허용하지 않기 때문에 다른 목적을 위한 상속에 무제가 발생한다.
	- 결합도 또한 증강하여 변경에 문제가 발생할 수 있다.
	- 추상 메서드로 분리한 부분이 매 구현체 마다 중복되어 작성될 가능성이 존재한다.

---
	
### DAO의 확장
```
- 본격적으로 컴포지션에 대해 설명한다.
- 컴포지션과 함께 DI에 대한 간단한 개념을 짚고 넘어가는 느낌이 강하게 든다.
- 이와 함께 solid와 디자인 패턴... 객체지향에 대한 기본적인 상식이 없다면, 읽을 수 있는 책일까?
```
- 클래스의 분리
	- 공통된 관심사를 상속이 아니라 새로운 클래스로 생성하여 사용한다.
	- 하지만 구현체를 그대로 가져다 쓰기 때문에 결합도에 의한 문제는 그대로 남아있다.
	
- 인터페이스의 도입
	- 인터페이스를 통해 결합도 문제를 어느정도 해결했다.
	- 하지만 여전히 객체를 바인딩 하는 코드가 클래스 안에 남아있기에 결합도 문제는 그대로 남아있다.
	
- 관계설정 책임의 분리
	- 구현 클래스간의 관계를 생성하는 곳은, 클래스를 사용하는 클라이언트 부분이다.
	- 객체사이의 바인딩 관계와 클래스사이의 바인딩 관계는 다르게 봐야 한다.(컴파일 타임 바인딩, 런타임 바인딩)
	- 생서자를 통해 콘크리트 객체를 주입함으로 위 문제를 해결할 수 있다.
	
- 원칙과 패턴
	- 개방폐쇄원칙(OCP)
		- 인터페이스를 이용하여 OCP를 만족시켰다. 먼저, 객체 내부에서는 외부에서 주입되는 객체의 구현을 모르기 때문에 그 구현의 변화에 의애 변경이 이러날
	가능성이 현저하게 낮아진다. 또한, 새로운 기능을 추가하기 위해서는 단순히 인터페이스를 구현한 새로운 구현체를 주입만 시켜주면 된다. 이를 통해 확장에 자유롭다.
		  
	- SOLID
		- 말해 뭐하는가. 당연히 알고있어야 하는 객체지향 5원칙.
---

### 높은 응집도와 낮은 결합도.
```
- 반드시 짚고 넘어가야 하는 부분. 응집도와 결합도는 객체지향의 근간이다.
```
- 높은 응집도
	- 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
	
- 낮은 결합도
	- "하나의 객체가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도"
	- 책임과 관심사가 다른 객체, 또는 모듈과는 느슨하게 유지되어야 한다.
	- 각 객체, 모듈이 서로 독립적으로 존재할 수 있도록 해야한다.
	
---
### 전략 패턴

---
### 제어의 역전(IoC)
- 팩토리
	- "객체의 생성 방법을 결정하고 만들어진 객체를 반환하는 것."
	- 팩토리를 통해 객체의 **생성**에 관한 책임을 분리할 수 있다.
	
- 설계도로서의 팩토리
    - 팩토리는 어플리케이션의 객체들을 구성하고 그 **관계를 정의하는 책임** <- 설계도의 역할을 한다
    - 핵심 로직에는 변경 없이 다양한 객체를 주입한 새로운 객체를 생성할 수 있다. -> 변경에 자유롭다.
  
- 오브젝트 팩토리의 활용

- 제어권의 이전을 통한 제어관계 역전
    - 프로그램의 제어 흐름 구조가 뒤바뀌는 것.
    - 객체가 자신이 사용할 객체를 스스로 선택, 생성하지 않음. 자신의 생성 및 사용 또한 모름. 다른 대상이 그 권한을 가지고 있기 때문.
    - 템플릿 메소드 패턴 또한 IoC의 한 부류이다 (자신이 구현한 메소드가 어디서 쓰일지 모른다. 자신은 필요할 때 호줄되어 사용된다.)
    - 프레임 워크 또한 제어의 역전 개념이 적용된 기술이다.
        - 라이브러리와 프레임워크는 다르다. 라이브러리는 애플리케이션의 흐름을 직접 제어한다.
        - 프레임워크는 어플리케이션 코드가 프레임 워크에 의해 사용된다(제어의 역전).
        - 프레임워크에는 제어의 역전 개념이 존재해야만 한다.
    - 어플리케이션 코드는 프레임워크의 틀 안에서 수동적으로 되어야 한다.
---

### 느낀점

전체적으로 매우 좋은 내용을 다루고 있다. 객체지향을 쉽게 풀어서 설명해 내고 있으며 스프링의 핵심 기술인 DI와 IoC를 예제를 기반으로 하여
설명한다.

다만 읽으면서 의심이 드는 부분이 있다면, IoC가 적용되는 순간 객체지향의 특성과 벗어나는 코드가 작성된다고 생각한다. 능동적인 객체간의 협력이 아닌,
수동적인 객체간의 강제로 만들어진 협력체... 객체지향이 아니라 객체지향을 흉내낸 느낌이랄까? 생각보다 마음에 들지는 않는다.
  



