# 토비의 스프링 정리 1장

---
## 1. DAO의 분리
전체적으로 OCP에 대한 내용을 쉽게 풀어서 설명하고 있다.

### 관심사의 분리
```
- 중복 코드의 추출, 상속, 컴포지션 순으로 코드의 재활용성 방법과 리팩토링 방법을 설명한다.
- 상속을 사용함으로써 발생하는 결합도에 대한 문제와 LSP와 같은 문제를 언급하며 결국 조합을 사용하도록 유도한다.
```

- 중복 코드 추출
    - 관심의 종류에 따라 코드를 분류하였기 때문에, 한가지 관심에 대한 변경이 자유롭다.
    
- 상속을 통한 확장
    - 템플릿 메소드 패턴을 통해 코드의 중복을 줄이고 유연한 객체를 생성할 수 있음.
    - 하지만 상속으로 인해 캡슐화에 문제가 발생하며 다중상속을 허용하지 않기 때문에 다른 목적을 위한 상속에 무제가 발생한다.
    - 결합도 또한 증강하여 변경에 문제가 발생할 수 있다.
    - 추상 메서드로 분리한 부분이 매 구현체 마다 중복되어 작성될 가능성이 존재한다.

---
    
### DAO의 확장
```
- 본격적으로 컴포지션에 대해 설명한다.
- 컴포지션과 함께 DI에 대한 간단한 개념을 짚고 넘어가는 느낌이 강하게 든다.
- 이와 함께 solid와 디자인 패턴... 객체지향에 대한 기본적인 상식이 없다면, 읽을 수 있는 책일까?
```
- 클래스의 분리
    - 공통된 관심사를 상속이 아니라 새로운 클래스로 생성하여 사용한다.
    - 하지만 구현체를 그대로 가져다 쓰기 때문에 결합도에 의한 문제는 그대로 남아있다.
    
- 인터페이스의 도입
    - 인터페이스를 통해 결합도 문제를 어느정도 해결했다.
    - 하지만 여전히 객체를 바인딩 하는 코드가 클래스 안에 남아있기에 결합도 문제는 그대로 남아있다.
    
- 관계설정 책임의 분리
    - 구현 클래스간의 관계를 생성하는 곳은, 클래스를 사용하는 클라이언트 부분이다.
    - 객체사이의 바인딩 관계와 클래스사이의 바인딩 관계는 다르게 봐야 한다.(컴파일 타임 바인딩, 런타임 바인딩)
    - 생서자를 통해 콘크리트 객체를 주입함으로 위 문제를 해결할 수 있다.
    
- 원칙과 패턴
    - 개방폐쇄원칙(OCP)
        - 인터페이스를 이용하여 OCP를 만족시켰다. 먼저, 객체 내부에서는 외부에서 주입되는 객체의 구현을 모르기 때문에 그 구현의 변화에 의애 변경이 이러날
    가능성이 현저하게 낮아진다. 또한, 새로운 기능을 추가하기 위해서는 단순히 인터페이스를 구현한 새로운 구현체를 주입만 시켜주면 된다. 이를 통해 확장에 자유롭다.
          
    - SOLID
        - 말해 뭐하는가. 당연히 알고있어야 하는 객체지향 5원칙.
---

### 높은 응집도와 낮은 결합도.
```
- 반드시 짚고 넘어가야 하는 부분. 응집도와 결합도는 객체지향의 근간이다.
```
- 높은 응집도
    - 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
    
- 낮은 결합도
    - "하나의 객체가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도"
    - 책임과 관심사가 다른 객체, 또는 모듈과는 느슨하게 유지되어야 한다.
    - 각 객체, 모듈이 서로 독립적으로 존재할 수 있도록 해야한다.
    
---
### 전략 패턴

---
### 제어의 역전(IoC)
- 팩토리
    - "객체의 생성 방법을 결정하고 만들어진 객체를 반환하는 것."
    - 팩토리를 통해 객체의 **생성**에 관한 책임을 분리할 수 있다.
    



